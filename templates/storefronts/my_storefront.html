{% extends "base.html" %}
{% load static %}

{% block content %}

<header class="sf-header">
  <div class="sf-header-main">
    <h1>My storefront</h1>
    <p class="text-muted">
      This is your public-facing page. Preview how it looks and update the details below.
    </p>
  </div>

  <div class="sf-header-actions">
    {% if storefront.is_active %}
    <span class="sf-badge sf-badge-success">Listed in Explore</span>
    {% else %}
    <span class="sf-badge sf-badge-muted">Hidden from Explore</span>
    {% endif %}

    <a href="{{ public_url }}" target="_blank" rel="noopener" class="btn btn-primary text-break">
      View public storefront
    </a>
  </div>
</header>

<div class="sf-grid">
  {# ================= LEFT: PREVIEW ================= #}
  <section class="sf-panel sf-panel-preview">
    <div class="sf-panel-heading">
      <h2>Preview</h2>
      <button type="button" class="sf-preview-edit-btn" id="sf-open-layout-editor">
        Edit layout
      </button>
    </div>

<div class="alert alert-info mt-2 mb-3 text-muted small">
  <strong>Tip:</strong> Edit Layout works best on <strong>desktop/tablet</strong>. On small touch screens, drag/resize positioning can be less precise.
</div>

    <div class="sf-preview-card w-100 overflow-hidden" id="sf-preview-card">
      <div class="sf-preview-logo">
        {% if storefront.logo %}
        <img src="{{ storefront.logo.url }}" alt="{{ storefront.headline }} logo" class="storefront-logo-large img-fluid">
        {% endif %}
      </div>

      <h3 class="sf-preview-headline">
        {{ storefront.headline|default:"Your storefront headline" }}
      </h3>

      <p class="sf-preview-body">
        {{ storefront.description|default:"Add a short description of your service or products." }}
      </p>

      <h4 class="sf-preview-section-title">Contact details</h4>
      <p class="sf-preview-body">
        {{ storefront.contact_details|default:"Add contact details customers can use to find or reach you." }}
      </p>
    </div>

    {# Featured cards - preview #}
    {% if has_cards %}
    <h3 class="storefront-section-heading">Featured digital cards</h3>

    <div class="sf-card-grid">
      {% for card in storefront.cards.all %}
      <article class="sf-card text-break">
        {% if card.image_url %}
        <div class="sf-card-image-wrap">
          <img src="{{ card.image_url }}" alt="{{ card.title|default:'Card' }}">
        </div>
        {% endif %}

        <h4 class="sf-card-title">
          {{ card.title|default:"Card " }}{% if not card.title %}{{ forloop.counter }}{% endif %}
          {% if card.price_label %}
          <span class="sf-card-price">{{ card.price_label }}</span>
          {% endif %}
        </h4>

        {% if card.description %}
        <p class="sf-card-text">{{ card.description }}</p>
        {% endif %}

        {% if card.buy_url %}
        <a href="{{ card.buy_url }}" target="_blank" rel="noopener"
          class="btn btn-sm btn-primary storefront-preview-card-button text-break">
          Buy now
        </a>
        {% endif %}
      </article>
      {% endfor %}
    </div>
    {% endif %}

    {% url 'storefront_detail' storefront.slug as public_path %}
    {% with public_url=request.scheme|add:"://"|add:request.get_host|add:public_path %}
    <p class="sf-public-link">
      Customers will see this page at:
      <a id="sf-public-url" href="{{ public_url }}" target="_blank" rel="noopener">{{ public_url }}</a>

      <button type="button" class="sf-link-action" data-action="copy">Copy</button>
      <button type="button" class="sf-link-action" data-action="share">Share</button>

      <span class="sf-link-status" id="sf-link-status" aria-live="polite"></span>
    </p>
    {% endwith %}

    <script>
      (function () {
        const link = document.getElementById('sf-public-url');
        const status = document.getElementById('sf-link-status');
        if (!link) return;

        function setStatus(msg) {
          if (!status) return;
          status.textContent = msg;
          window.clearTimeout(setStatus._t);
          setStatus._t = window.setTimeout(() => status.textContent = '', 1800);
        }

        async function copyUrl() {
          const url = link.href;
          try {
            await navigator.clipboard.writeText(url);
            setStatus('Copied!');
          } catch (e) {
            const tmp = document.createElement('textarea');
            tmp.value = url;
            tmp.setAttribute('readonly', '');
            tmp.style.position = 'absolute';
            tmp.style.left = '-9999px';
            document.body.appendChild(tmp);
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
            setStatus('Copied!');
          }
        }

        async function shareUrl() {
          const url = link.href;
          if (navigator.share) {
            try {
              await navigator.share({ title: 'MintKit Storefront', url });
              setStatus('Shared.');
              return;
            } catch (e) { }
          }
          await copyUrl();
        }

        document.querySelectorAll('.sf-link-action').forEach(btn => {
          btn.addEventListener('click', () => {
            const action = btn.getAttribute('data-action');
            if (action === 'share') shareUrl();
            else copyUrl();
          });
        });
      })();
    </script>

  </section>

  {# ================= RIGHT: EDIT FORM ================= #}
  <section class="sf-panel">
    <h2>Edit storefront details</h2>

    <form method="post" enctype="multipart/form-data">
      {% csrf_token %}
      {{ form.non_field_errors }}

      {# Category + region row #}
      <div class="form-row storefront-form-row">
        <div class="form-group storefront-form-group">
          <label for="{{ form.business_category.id_for_label }}">
            Business Category <span class="text-danger">*</span>
          </label>
          {{ form.business_category }}
          {# Match Django aria-describedby target when help_text exists #}
          {% if form.business_category.help_text %}
          <div class="sf-form-help" id="id_business_category_helptext">
            {{ form.business_category.help_text }}
          </div>
          {% else %}
          <div class="sf-form-help" id="id_business_category_helptext"></div>
          {% endif %}
          {{ form.business_category.errors }}
        </div>

        <div class="form-group storefront-form-group">
          <label for="{{ form.region.id_for_label }}">
            Region <span class="text-danger">*</span>
          </label>
          {{ form.region }}
          {# Match Django aria-describedby target when help_text exists #}
          {% if form.region.help_text %}
          <div class="sf-form-help" id="id_region_helptext">
            {{ form.region.help_text }}
          </div>
          {% else %}
          <div class="sf-form-help" id="id_region_helptext"></div>
          {% endif %}
          {{ form.region.errors }}
        </div>
      </div>

      <hr class="sf-form-divider">

      {# Logo upload #}
      <div class="sf-form-row sf-logo-row">
        <label for="{{ form.logo.id_for_label }}">Storefront logo:</label>

        {% if storefront.logo %}
        <div class="sf-logo-current">
          <img src="{{ storefront.logo.url }}" alt="{{ storefront.headline|default:'Storefront logo' }}">
          <div class="sf-form-help">
            This logo appears above the preview on the left and on your public page.
            <p class="text-muted small">
              To change your logo, upload a new file and click <em>Save storefront</em>.
              If you leave this field empty, your current logo will stay the same.
            </p>
          </div>
        </div>
        {% endif %}

        {{ form.logo }}
        <div class="sf-form-help" id="id_logo_helptext">
          Upload a logo (optional). Recommended: .webp, landscape works best.
        </div>
        {{ form.logo.errors }}
      </div>

      <p class="text-muted">
        Update the text shown on your public page. You can toggle public visibility here as well.
      </p>

      {# Headline #}
      <div class="sf-form-row">
        <label for="{{ form.headline.id_for_label }}">Storefront headline:</label>
        {{ form.headline }}
        <div class="sf-form-help" id="id_headline_helptext">
          Shown as the main title of your storefront.
        </div>
      </div>

      {# Description #}
      <div class="sf-form-row">
        <label for="{{ form.description.id_for_label }}">Description:</label>
        {{ form.description }}
        <div class="sf-form-help" id="id_description_helptext">
          Appears as the main body text on your storefront page.
        </div>
      </div>

      {# Contact details #}
      <div class="sf-form-row">
        <label for="{{ form.contact_details.id_for_label }}">Contact details:</label>
        {{ form.contact_details }}
        <div class="sf-form-help" id="id_contact_details_helptext">
          These details help customers contact or find you.
        </div>
      </div>

      {# Public toggle #}
      <div class="sf-form-row sf-form-row-public">
        <div class="sf-form-inline">
          <label class="sf-checkbox-label">
            {{ form.is_active }}
            <span>Make my storefront public</span>
          </label>
        </div>
        <div class="sf-form-help" id="id_is_active_helptext">
          Tick this when you're ready for customers to see your page (and list it in Explore).
        </div>
      </div>

      {# ========= Featured cards - collapsible formset ========= #}
      {{ card_formset.management_form }}

      <details class="sf-card-formset-wrapper">
        <summary class="sf-card-summary">
          <span class="sf-card-summary-content">
            <span class="sf-card-summary-left">
              <span class="sf-card-summary-label">Featured digital cards (optional)</span>
            </span>

            <span class="sf-card-summary-right">
              <img src="{% static 'img/logo-blue.webp' %}" alt="Featured cards preview" class="sf-card-summary-thumb img-fluid">
            </span>
          </span>
        </summary>

        <p class="text-muted small">
          Add up to three MintKit cards to highlight on your storefront.
          Paste the <code>thumbnail.webp</code> image URL and the link customers should use to buy.
          These cards will appear in the Preview on the left and on your public storefront.
        </p>

        <div class="sf-card-formset">
          {% for card_form in card_formset %}
          <div class="sf-card-form">
            <h4 class="sf-card-form-title">Card {{ forloop.counter }}</h4>

            {{ card_form.id }}

            <div class="sf-form-row">
              <label for="{{ card_form.title.id_for_label }}">Card title</label>
              {{ card_form.title }}
              <div class="sf-form-help" id="id_cards-{{ forloop.counter0 }}-title_helptext"></div>
            </div>

            <div class="sf-form-row">
              <label for="{{ card_form.price_label.id_for_label }}">Price label (optional)</label>
              {{ card_form.price_label }}
              <div class="sf-form-help" id="id_cards-{{ forloop.counter0 }}-price_label_helptext"></div>
            </div>

            <div class="sf-form-row">
              <label for="{{ card_form.buy_url.id_for_label }}">Buy / details link</label>
              {{ card_form.buy_url }}
              <div class="sf-form-help" id="id_cards-{{ forloop.counter0 }}-buy_url_helptext"></div>
            </div>

            <div class="sf-form-row">
              <label for="{{ card_form.image_url.id_for_label }}">Thumbnail image URL</label>
              {{ card_form.image_url }}
              <div class="sf-form-help" id="id_cards-{{ forloop.counter0 }}-image_url_helptext"></div>
            </div>

            <div class="sf-form-row">
              <label for="{{ card_form.description.id_for_label }}">Short description (optional)</label>
              {{ card_form.description }}
              <div class="sf-form-help" id="id_cards-{{ forloop.counter0 }}-description_helptext"></div>
            </div>

            <div class="sf-form-row">
              <label>
                {{ card_form.DELETE }}
                Remove this card from your storefront
              </label>
              <div class="sf-form-help" id="id_cards-{{ forloop.counter0 }}-DELETE_helptext"></div>
            </div>
          </div>
          {% endfor %}
        </div>
      </details>

      {# Actions #}
      <div class="form-actions">
        <button type="submit" class="btn btn-primary">Save storefront</button>
        <a href="{% url 'dashboard' %}" class="btn btn-secondary text-break">Cancel</a>
      </div>
    </form>
  </section>
</div>

{# ========== Full-screen layout editor overlay ========== #}
<div id="sf-layout-editor" class="sf-layout-editor-overlay" aria-hidden="true" data-storefront-id="{{ storefront.id }}">

  <div class="sf-layout-editor-backdrop" id="sf-layout-editor-backdrop"></div>

  <div class="sf-layout-editor-dialog" role="dialog" aria-modal="true" aria-labelledby="sf-layout-editor-title">
    <header class="sf-layout-editor-header">
      <h2 id="sf-layout-editor-title">Customize storefront layout</h2>
      <button type="button" class="sf-layout-editor-close" id="sf-close-layout-editor">
        Close
      </button>

    </header>

    <div class="sf-layout-editor-body">

      <div class="sf-layout-editor-toolbar">
        <div class="sf-toolbar-group">
          <label for="sf-font-family">Font</label>
          <select id="sf-font-family">
            <option value="">Default</option>
            <option value="'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif">Inter</option>
            <option value="'Roboto', system-ui, -apple-system, 'Segoe UI', Arial, sans-serif">Roboto</option>
            <option value="'Montserrat', system-ui, -apple-system, 'Segoe UI', Arial, sans-serif">Montserrat</option>
            <option value="Georgia, 'Times New Roman', serif">Georgia</option>
            <option value="'Times New Roman', serif">Times New Roman</option>
            <option value="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace">
              Monospace</option>
          </select>
        </div>

        <div class="sf-toolbar-group">
          <label for="sf-font-size">Size (px)</label>
          <input id="sf-font-size" type="number" min="10" max="96" step="1" placeholder="Default">
        </div>

        <div class="sf-toolbar-group">
          <label>Style</label>
          <div class="sf-toolbar-inline-buttons">
            <button type="button" id="sf-font-bold" class="sf-toolbar-button sf-toolbar-button-toggle" title="Bold">
              <strong>B</strong>
            </button>
            <button type="button" id="sf-font-italic" class="sf-toolbar-button sf-toolbar-button-toggle" title="Italic">
              <em>I</em>
            </button>
            <button type="button" id="sf-font-underline" class="sf-toolbar-button sf-toolbar-button-toggle"
              title="Underline">
              <span style="text-decoration: underline;">U</span>
            </button>
          </div>
        </div>

        <div class="sf-toolbar-group">
          <label for="sf-bg-color">Page background</label>
          <input id="sf-bg-color" type="color" value="#ffffff">
        </div>

        <div class="sf-toolbar-group" style="margin-left: auto;">
          <button type="button" id="sf-fit-toggle" class="sf-toolbar-button" title="Fit page into view">
            Fit
          </button>

          <button type="button" id="sf-hide-block" class="sf-toolbar-button sf-toolbar-button-danger" disabled>
            Hide block
          </button>
          <button type="button" id="sf-reset-block" class="sf-toolbar-button" disabled>
            Reset styles
          </button>
          <button type="button" class="btn btn-primary" id="sf-save-layout">
            Save layout
          </button>

          <span id="sf-save-status" class="ms-2 text-muted" style="font-size: 0.9rem;">
            Not saved yet
          </span>

        </div>
      </div>

      <div class="sf-layout-editor-canvas" id="sf-editor-canvas">
        <div class="sf-layout-editor-surface" id="sf-editor-surface">
          <div class="sf-preview-card sf-preview-card--editor" id="sf-editor-content">

            <div class="sf-preview-logo" data-sf-block="logo" data-sf-label="Logo">
              {% if storefront.logo %}
              <img src="{{ storefront.logo.url }}" alt="{{ storefront.headline }} logo" class="storefront-logo-large img-fluid">
              {% endif %}
            </div>

            <h3 class="sf-preview-headline" data-sf-block="headline" data-sf-label="Headline">
              {{ storefront.headline|default:"Your storefront headline" }}
            </h3>

            <p class="sf-preview-body" data-sf-block="description" data-sf-label="Description">
              {{ storefront.description|default:"Add a short description of your service or products." }}
            </p>

            <h4 class="sf-preview-section-title" data-sf-block="contact_title" data-sf-label="Contact title">
              Contact details
            </h4>

            <p class="sf-preview-body" data-sf-block="contact_text" data-sf-label="Contact text">
              {{ storefront.contact_details|default:"Add contact details customers can use to find or reach you." }}
            </p>

            {% if has_cards %}
            <h3 class="storefront-section-heading" data-sf-block="cards_title" data-sf-label="Featured cards title">
              Featured digital cards
            </h3>

            <div class="sf-card-grid" data-sf-label="Cards grid">
              {% for card in storefront.cards.all|slice:":3" %}
              <article class="sf-card text-break" data-sf-block="card_{{ forloop.counter }}"
                data-sf-label="Card {{ forloop.counter }}">
                {% if card.image_url %}
                <div class="sf-card-image-wrap">
                  <img src="{{ card.image_url }}" alt="{{ card.title|default:'Card' }}">
                </div>
                {% endif %}

                <h4 class="sf-card-title">
                  {{ card.title|default:"Card " }}{% if not card.title %}{{ forloop.counter }}{% endif %}
                  {% if card.price_label %}
                  <span class="sf-card-price">{{ card.price_label }}</span>
                  {% endif %}
                </h4>

                {% if card.description %}
                <p class="sf-card-text">{{ card.description }}</p>
                {% endif %}

                {% if card.buy_url %}
                <a href="{{ card.buy_url }}" target="_blank" rel="noopener"
                  class="btn btn-sm btn-primary storefront-preview-card-button text-break">
                  Buy now
                </a>
                {% endif %}
              </article>
              {% endfor %}
            </div>
            {% endif %}

          </div>
        </div>
      </div>

      <p class="sf-layout-editor-hint text-muted">
        Draft layout editor — drag blocks to move them, and use the small corner handle to resize.
      </p>

    </div>
  </div>
</div>

{# JS unchanged below #}
<script>
  /*
    Storefront layout editor — merged “stable + save” version

    Fixes in this version:
    1) No more “mystical top block” — #sf-editor-content is used only for measuring, then hidden.
    2) Better default widths (avoid 100% feeling), still clamped to surface width.
    3) Fit mode no longer makes the page super tall:
       - Compute a scale factor to fit the whole surface into the visible canvas width.
       - Also set the surface height/width so scrolling matches the scaled size.
    4) Fit button shows ON state (adds .is-active on the button).
    5) Font reliability improved (Inter/Roboto/Montserrat):
       - Inject Google Fonts once
       - Re-apply after fonts are ready (fixes “needs 2 clicks”)
    6) Font size applies to headings too (Featured digital cards / Contact details etc.)
    7) Page can grow vertically: drag/resize blocks below the current bottom and the surface expands.
    8) Save layout to the database (loads on open, saves via button).
  */

  (function () {
    const editor = document.getElementById("sf-layout-editor");
    if (!editor) return;

    const openBtn = document.getElementById("sf-open-layout-editor");
    const closeBtn = document.getElementById("sf-close-layout-editor");
    const backdrop = document.getElementById("sf-layout-editor-backdrop");

    const canvas = document.getElementById("sf-editor-canvas");
    const surface = document.getElementById("sf-editor-surface");
    const content = document.getElementById("sf-editor-content");

    const fontSelect = document.getElementById("sf-font-family");
    const sizeInput = document.getElementById("sf-font-size");
    const boldBtn = document.getElementById("sf-font-bold");
    const italicBtn = document.getElementById("sf-font-italic");
    const underBtn = document.getElementById("sf-font-underline");
    const bgInput = document.getElementById("sf-bg-color");

    const fitBtn = document.getElementById("sf-fit-toggle");
    const hideBtn = document.getElementById("sf-hide-block");
    const resetBtn = document.getElementById("sf-reset-block");

    const saveBtn = document.getElementById("sf-save-layout");
    const saveStatus = document.getElementById("sf-save-status");

    const storefrontId = editor.getAttribute("data-storefront-id");

    // Make toolbar sticky again (no CSS file change needed)
    const toolbar = document.querySelector(".sf-layout-editor-toolbar");
    if (toolbar) {
      toolbar.style.position = "sticky";
      toolbar.style.top = "0";
      toolbar.style.zIndex = "5";
    }

    const KEY_LAYOUT = "sf_layout_v4:" + location.pathname;
    const KEY_STYLES = "sf_styles_v4:" + location.pathname;
    const KEY_BG = "sf_bg_v4:" + location.pathname;


    // Keep the LEFT preview background in sync with the saved page background
    const previewCard = document.getElementById("sf-preview-card");

    function applyPreviewBg(color) {
      if (!previewCard) return;
      previewCard.style.background = (color || "#ffffff");
    }

    async function initPreviewBg() {
      // Fast path: use cached background if present
      const cached = localStorage.getItem(KEY_BG);
      if (cached) {
        applyPreviewBg(cached);
        return;
      }

      // Otherwise fetch from server so preview matches the public storefront
      try {
        await loadFromServer();
        const serverBg = localStorage.getItem(KEY_BG);
        if (serverBg) {
          applyPreviewBg(serverBg);
          return;
        }
      } catch (e) {
        // Keep default background if load fails
      }

      applyPreviewBg("#ffffff");
    }

    // Run once on page load (editor not required)
    initPreviewBg();

    function readJSON(key, fallback) {
      try { return JSON.parse(localStorage.getItem(key)) ?? fallback; }
      catch { return fallback; }
    }
    function writeJSON(key, value) {
      try { localStorage.setItem(key, JSON.stringify(value)); }
      catch { /* ignore */ }
    }

    function setStatus(text, isError) {
      if (!saveStatus) return;
      saveStatus.textContent = text;
      saveStatus.style.color = isError ? "#b42318" : "";
    }

    function getCookie(name) {
      const v = document.cookie
        .split(";")
        .map(s => s.trim())
        .find(s => s.startsWith(name + "="));
      return v ? decodeURIComponent(v.split("=")[1]) : null;
    }

    async function loadFromServer() {
      if (!storefrontId) return;

      const url = `/storefront/${storefrontId}/layout/load/`;
      const res = await fetch(url, { credentials: "same-origin" });
      if (!res.ok) return;

      const data = await res.json();

      localStorage.setItem(KEY_LAYOUT, JSON.stringify(data.layout || {}));
      localStorage.setItem(KEY_STYLES, JSON.stringify(data.styles || {}));
      localStorage.setItem(KEY_BG, data.bg || "#ffffff");
    }

    async function saveToServer() {
      if (!storefrontId) {
        setStatus("Missing storefront id", true);
        return;
      }

      const url = `/storefront/${storefrontId}/layout/save/`;
      const payload = {
        layout: readJSON(KEY_LAYOUT, {}),
        styles: readJSON(KEY_STYLES, {}),
        bg: localStorage.getItem(KEY_BG) || "#ffffff",
      };

      const res = await fetch(url, {
        method: "POST",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": getCookie("csrftoken"),
        },
        body: JSON.stringify(payload),
      });

      const data = await res.json().catch(() => ({}));

      if (!res.ok || !data.ok) {
        setStatus("Save failed", true);
        return;
      }

      setStatus("Saved ✔", false);
    }

    let zCounter = 10;
    let selectedId = null;
    let fitEnabled = false;
    let fitScale = 1;

    const blocks = new Map();

    // --- Vertical growth (make the page taller when blocks are pushed down) ---
    let surfaceBaseMinH = 0;

    function ensureSurfaceMinHeight(extraPad = 120) {
      if (!surface) return;

      if (!surfaceBaseMinH) {
        surfaceBaseMinH = Math.max(surface.offsetHeight || 0, window.innerHeight || 0);
      }

      let maxBottom = 0;
      blocks.forEach((b) => {
        const top = parseFloat(b.style.top) || 0;
        const h = parseFloat(b.style.height) || b.offsetHeight || 0;
        const bottom = top + h;
        if (bottom > maxBottom) maxBottom = bottom;
      });

      const wanted = Math.max(surfaceBaseMinH, Math.ceil(maxBottom + extraPad));
      surface.style.minHeight = wanted + "px";
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    // --- Font reliability (Inter/Roboto/Montserrat) ---
    let fontsInjected = false;

    function injectGoogleFontsOnce() {
      if (fontsInjected) return;
      fontsInjected = true;

      if (document.getElementById("sf-google-fonts")) return;

      const link = document.createElement("link");
      link.id = "sf-google-fonts";
      link.rel = "stylesheet";
      link.href =
        "https://fonts.googleapis.com/css2?" +
        "family=Inter:wght@400;500;600;700&" +
        "family=Roboto:wght@400;500;700&" +
        "family=Montserrat:wght@400;500;600;700&" +
        "display=swap";

      document.head.appendChild(link);
    }

    function setEditorOpen(isOpen) {
      editor.setAttribute("aria-hidden", isOpen ? "false" : "true");
      editor.classList.toggle("is-open", isOpen);
      document.body.classList.toggle("sf-editor-lock", isOpen);
    }

    async function openEditor() {
      setEditorOpen(true);

      setStatus("Loading…", false);
      try {
        await loadFromServer();
      } catch {
        // Network failures should not block editing
      }

      // Ensure common fonts are available, then rebuild after fonts are ready
      injectGoogleFontsOnce();
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
          if (editor.classList.contains("is-open")) rebuildBlocks();
        });
      }

      rebuildBlocks();
      setStatus("Loaded", false);
    }

    function closeEditor() {
      setEditorOpen(false);
      selectBlock(null);
      clearBlocks();

      // Restore original preview wrapper for next measurement pass
      content.style.display = "";
      content.style.visibility = "";
      content.style.pointerEvents = "";

      // Reset fit transform
      fitEnabled = false;
      fitScale = 1;
      applyFitVisuals(false);
      clearFitTransform();
    }

    if (openBtn) openBtn.addEventListener("click", openEditor);
    if (closeBtn) closeBtn.addEventListener("click", closeEditor);
    if (backdrop) backdrop.addEventListener("click", closeEditor);

    if (saveBtn) {
      saveBtn.addEventListener("click", async () => {
        setStatus("Saving…", false);
        try {
          await saveToServer();
        } catch {
          setStatus("Save failed", true);
        }
      });
    }

    // Prevent navigation inside editor (buttons/links inside cloned preview)
    surface.addEventListener("click", function (e) {
      if (e.target.closest("a,button")) {
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);

    function clearBlocks() {
      blocks.forEach((el) => el.remove());
      blocks.clear();
    }

    // Typography helpers
    function applyTextStyles(container, st) {
      if (!container) return;

      const px = st.fontSize ? (st.fontSize + "px") : "";

      container.style.fontFamily = st.fontFamily || "";
      container.style.fontSize = px;
      container.style.fontWeight = st.bold ? "700" : "";
      container.style.fontStyle = st.italic ? "italic" : "";
      container.style.textDecoration = st.underline ? "underline" : "";

      // Force override on common text elements so headings change too
      const textNodes = container.querySelectorAll("h1,h2,h3,h4,h5,h6,p,span,a,small,li,label,strong,em");
      textNodes.forEach((el) => {
        el.style.fontFamily = st.fontFamily || "";
        el.style.fontSize = px;
        el.style.fontWeight = st.bold ? "700" : "";
        el.style.fontStyle = st.italic ? "italic" : "";
        el.style.textDecoration = st.underline ? "underline" : "";
      });

      // Make images scale with the block (helps logo + card thumbnails)
      const imgs = container.querySelectorAll("img");
      imgs.forEach((img) => {
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        img.style.display = "block";
      });
    }

    // Fit helpers (stable)
    function applyFitVisuals(isOn) {
      if (!fitBtn) return;

      fitBtn.classList.toggle("is-active", isOn);
      fitBtn.setAttribute("aria-pressed", isOn ? "true" : "false");

      // Visible ON state without touching CSS file
      if (isOn) {
        fitBtn.style.boxShadow = "0 0 0 3px rgba(79, 70, 229, 0.18)";
        fitBtn.style.borderColor = "rgba(79, 70, 229, 0.9)";
      } else {
        fitBtn.style.boxShadow = "";
        fitBtn.style.borderColor = "";
      }
    }

    function clearFitTransform() {
      surface.style.transform = "";
      surface.style.transformOrigin = "";
      surface.style.width = "";
      surface.style.height = "";
      if (canvas) canvas.style.minHeight = "";
    }

    function computeAndApplyFit() {
      if (!canvas) return;

      // Always compute from "natural" (unscaled) measurements
      clearFitTransform();

      const pad = 24; // small breathing space
      const vw = canvas.clientWidth - pad;
      const vh = canvas.clientHeight - pad;

      const naturalW = surface.scrollWidth || surface.offsetWidth;
      const naturalH = surface.scrollHeight || surface.offsetHeight;

      // Fit BOTH width & height (never upscale)
      fitScale = Math.min(vw / naturalW, vh / naturalH, 1);

      surface.style.transformOrigin = "top left";
      surface.style.transform = `scale(${fitScale})`;

      // Important: keep scroll area aligned to the scaled size (prevents “super tall” feel)
      surface.style.width = naturalW + "px";
      surface.style.height = naturalH + "px";

      canvas.style.minHeight = Math.ceil(naturalH * fitScale + 40) + "px";
    }

    // Recalculate Fit when window changes size (only when open + fit enabled)
    window.addEventListener("resize", () => {
      if (!editor.classList.contains("is-open")) return;
      if (!fitEnabled) return;
      computeAndApplyFit();
    });

    function rebuildBlocks() {
      clearBlocks();

      // Show original wrapper so can measure positions
      content.style.display = "";
      content.style.visibility = "";
      content.style.pointerEvents = "none";

      // Background applies to the actual surface (page)
      const savedBg = localStorage.getItem(KEY_BG);
      if (savedBg) {
        surface.style.background = savedBg;
        bgInput.value = savedBg;
        applyPreviewBg(savedBg);
      } else {
        surface.style.background = "#ffffff";
        bgInput.value = "#ffffff";
        applyPreviewBg("#ffffff");
      }

      const marked = content.querySelectorAll("[data-sf-block]");
      if (!marked.length) return;

      const savedLayout = readJSON(KEY_LAYOUT, {});
      const savedStyles = readJSON(KEY_STYLES, {});

      const surfaceRect = surface.getBoundingClientRect();
      const surfaceW = surface.clientWidth;
      marked.forEach((node) => {
        const id = node.getAttribute("data-sf-block");
        const label = node.getAttribute("data-sf-label") || id;

        const rect = node.getBoundingClientRect();
        const baseW = rect.width;
        const baseH = rect.height;

        const defaultX = rect.left - surfaceRect.left;
        const defaultY = rect.top - surfaceRect.top;

        // Preferred default sizing logic (25% when the element “feels wide”)
        const targetW = (baseW > surfaceW * 0.30)
          ? Math.floor(surfaceW * 0.25)
          : Math.floor(baseW * 1.15);

        // Allow logo to go smaller than other blocks
        const isLogo = id === "logo";
        const minW = isLogo ? 140 : 240;
        const minH = isLogo ? 140 : 90;

        const fallbackLayout = {
          x: Math.max(0, defaultX),
          y: Math.max(0, defaultY),
          w: clamp(targetW, minW, surfaceW - 20),
          h: Math.max(minH, Math.floor(baseH * 1.20)),
        };

        const layout = savedLayout[id] || fallbackLayout;

        const safeW = clamp(layout.w, minW, surfaceW - 20);
        const safeH = Math.max(minH, layout.h);

        const safeX = clamp(layout.x, 0, surfaceW - safeW - 10);
        const safeY = clamp((layout.y ?? 0), 0, 8000);

        const block = document.createElement("div");
        block.className = "sf-layout-block";
        block.setAttribute("data-block-id", id);
        block.style.left = safeX + "px";
        block.style.top = safeY + "px";
        block.style.width = safeW + "px";
        block.style.height = safeH + "px";
        block.style.zIndex = (++zCounter).toString();

        const labelEl = document.createElement("div");
        labelEl.className = "sf-layout-block-label";
        labelEl.textContent = label;

        const contentWrap = document.createElement("div");
        contentWrap.className = "sf-layout-block-content";
        contentWrap.appendChild(node.cloneNode(true));

        const st = savedStyles[id] || {};
        applyTextStyles(contentWrap, st);
        if (st.hidden) block.classList.add("sf-layout-block-hidden");

        const handle = document.createElement("div");
        handle.className = "sf-layout-resize-handle";
        handle.title = "Resize";

        block.appendChild(labelEl);
        block.appendChild(contentWrap);
        block.appendChild(handle);
        surface.appendChild(block);

        blocks.set(id, block);

        block.addEventListener("pointerdown", (e) => {
          if (e.target === handle) return;
          selectBlock(id);
          startDrag(e, block);
        });

        handle.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          selectBlock(id);
          startResize(e, block, { minW, minH });
        });
      });

      // Hide originals so only draggable blocks are visible
      content.style.display = "none";

      // Grow the surface so blocks can be pushed further down
      ensureSurfaceMinHeight();

      // Re-apply fit if enabled
      if (fitEnabled) computeAndApplyFit();
    }

    function selectBlock(id) {
      selectedId = id;
      blocks.forEach((b) => b.classList.remove("sf-layout-block-selected"));

      if (!id || !blocks.has(id)) {
        hideBtn.disabled = true;
        resetBtn.disabled = true;
        fontSelect.value = "";
        sizeInput.value = "";
        boldBtn.classList.remove("is-active");
        italicBtn.classList.remove("is-active");
        underBtn.classList.remove("is-active");
        return;
      }

      const block = blocks.get(id);
      block.classList.add("sf-layout-block-selected");
      block.style.zIndex = (++zCounter).toString();

      hideBtn.disabled = false;
      resetBtn.disabled = false;

      const savedStyles = readJSON(KEY_STYLES, {});
      const st = savedStyles[id] || {};

      fontSelect.value = st.fontFamily || "";
      sizeInput.value = st.fontSize ? String(st.fontSize) : "";

      boldBtn.classList.toggle("is-active", !!st.bold);
      italicBtn.classList.toggle("is-active", !!st.italic);
      underBtn.classList.toggle("is-active", !!st.underline);
    }

    function saveLayoutFromBlock(block) {
      const id = block.getAttribute("data-block-id");
      const surfaceW = surface.clientWidth;
      let x = parseFloat(block.style.left) || 0;
      let y = parseFloat(block.style.top) || 0;
      let w = parseFloat(block.style.width) || 300;
      let h = parseFloat(block.style.height) || 120;

      // Keep saved layout inside the surface bounds
      w = clamp(w, 140, surfaceW - 20);
      x = clamp(x, 0, surfaceW - w - 10);

      // Allow tall pages: only prevent negative values and cap to a sane maximum
      y = clamp(y, 0, 8000);

      block.style.left = x + "px";
      block.style.top = y + "px";
      block.style.width = w + "px";

      // Keep the surface tall enough to include this block
      ensureSurfaceMinHeight();

      const saved = readJSON(KEY_LAYOUT, {});
      saved[id] = { x, y, w, h };
      writeJSON(KEY_LAYOUT, saved);

      setStatus("Not saved yet", false);
    }

    function updateStyleForSelected(patch) {
      if (!selectedId) return;

      const saved = readJSON(KEY_STYLES, {});
      const current = saved[selectedId] || {};
      saved[selectedId] = { ...current, ...patch };
      writeJSON(KEY_STYLES, saved);

      const block = blocks.get(selectedId);
      if (!block) return;

      const contentWrap = block.querySelector(".sf-layout-block-content");
      if (!contentWrap) return;

      const st = saved[selectedId];
      applyTextStyles(contentWrap, st);

      block.classList.toggle("sf-layout-block-hidden", !!st.hidden);

      boldBtn.classList.toggle("is-active", !!st.bold);
      italicBtn.classList.toggle("is-active", !!st.italic);
      underBtn.classList.toggle("is-active", !!st.underline);

      setStatus("Not saved yet", false);
    }

    fontSelect.addEventListener("change", () => selectedId && updateStyleForSelected({ fontFamily: fontSelect.value }));

    sizeInput.addEventListener("input", () => {
      if (!selectedId) return;
      const n = parseInt(sizeInput.value, 10);
      if (Number.isFinite(n) && n > 0) updateStyleForSelected({ fontSize: n });
      if (sizeInput.value === "") updateStyleForSelected({ fontSize: null });
    });

    boldBtn.addEventListener("click", () => {
      if (!selectedId) return;
      const st = (readJSON(KEY_STYLES, {})[selectedId] || {});
      updateStyleForSelected({ bold: !st.bold });
    });

    italicBtn.addEventListener("click", () => {
      if (!selectedId) return;
      const st = (readJSON(KEY_STYLES, {})[selectedId] || {});
      updateStyleForSelected({ italic: !st.italic });
    });

    underBtn.addEventListener("click", () => {
      if (!selectedId) return;
      const st = (readJSON(KEY_STYLES, {})[selectedId] || {});
      updateStyleForSelected({ underline: !st.underline });
    });

    bgInput.addEventListener("input", () => {
      surface.style.background = bgInput.value;
      applyPreviewBg(bgInput.value);
      localStorage.setItem(KEY_BG, bgInput.value);
      setStatus("Not saved yet", false);
    });

    hideBtn.addEventListener("click", () => {
      if (!selectedId) return;
      const st = (readJSON(KEY_STYLES, {})[selectedId] || {});
      updateStyleForSelected({ hidden: !st.hidden });
    });

    resetBtn.addEventListener("click", () => {
      if (!selectedId) return;
      const saved = readJSON(KEY_STYLES, {});
      delete saved[selectedId];
      writeJSON(KEY_STYLES, saved);
      rebuildBlocks();
      setStatus("Not saved yet", false);
    });

    fitBtn.addEventListener("click", () => {
      fitEnabled = !fitEnabled;
      applyFitVisuals(fitEnabled);

      if (!fitEnabled) {
        clearFitTransform();
        return;
      }

      computeAndApplyFit();
    });

    function startDrag(e, block) {
      e.preventDefault();
      block.classList.add("sf-layout-block--dragging");
      block.style.zIndex = (++zCounter).toString();

      const startX = e.clientX;
      const startY = e.clientY;

      const startLeft = parseFloat(block.style.left) || 0;
      const startTop = parseFloat(block.style.top) || 0;

      block.setPointerCapture(e.pointerId);

      function onMove(ev) {
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;

        const w = parseFloat(block.style.width) || 300;
        const h = parseFloat(block.style.height) || 120;

        const surfaceW = surface.clientWidth;

        const maxLeft = Math.max(0, surfaceW - w - 10);

        const nextLeft = clamp(startLeft + dx, 0, maxLeft);
        const nextTop = clamp(startTop + dy, 0, 8000);

        block.style.left = nextLeft + "px";
        block.style.top = nextTop + "px";

        // Allow the page to grow vertically when blocks are moved down
        if (nextTop + h + 120 > (surface.offsetHeight || 0)) {
          ensureSurfaceMinHeight();
        }
      }

      function onUp(ev) {
        block.classList.remove("sf-layout-block--dragging");
        block.releasePointerCapture(ev.pointerId);

        block.removeEventListener("pointermove", onMove);
        block.removeEventListener("pointerup", onUp);

        saveLayoutFromBlock(block);

        // Keep the surface tall after moving the block
        ensureSurfaceMinHeight();

        // If fit is ON, re-fit after changes (keeps preview accurate)
        if (fitEnabled) computeAndApplyFit();
      }

      block.addEventListener("pointermove", onMove);
      block.addEventListener("pointerup", onUp);
    }

    function startResize(e, block, limits) {
      e.preventDefault();
      block.classList.add("sf-layout-block--resizing");
      block.style.zIndex = (++zCounter).toString();

      const minW = limits?.minW ?? 240;
      const minH = limits?.minH ?? 90;

      const startX = e.clientX;
      const startY = e.clientY;

      const startW = parseFloat(block.style.width) || 320;
      const startH = parseFloat(block.style.height) || 140;

      block.setPointerCapture(e.pointerId);

      function onMove(ev) {
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;

        const surfaceW = surface.clientWidth;

        const left = parseFloat(block.style.left) || 0;
        const top = parseFloat(block.style.top) || 0;

        const maxW = Math.max(minW, surfaceW - left - 10);

        const nextW = clamp(startW + dx, minW, maxW);
        const nextH = clamp(startH + dy, minH, 8000);

        block.style.width = nextW + "px";
        block.style.height = nextH + "px";

        // Allow the page to grow vertically when blocks are resized down
        if (top + nextH + 120 > (surface.offsetHeight || 0)) {
          ensureSurfaceMinHeight();
        }
      }

      function onUp(ev) {
        block.classList.remove("sf-layout-block--resizing");
        block.releasePointerCapture(ev.pointerId);

        block.removeEventListener("pointermove", onMove);
        block.removeEventListener("pointerup", onUp);

        saveLayoutFromBlock(block);

        // Keep the surface tall after resizing the block
        ensureSurfaceMinHeight();

        // If fit is ON, re-fit after changes
        if (fitEnabled) computeAndApplyFit();
      }

      block.addEventListener("pointermove", onMove);
      block.addEventListener("pointerup", onUp);
    }

    document.addEventListener("keydown", function (e) {
      if (!editor.classList.contains("is-open")) return;
      if (e.key === "Escape") closeEditor();
    });

    // Initialise Fit button visuals off
    applyFitVisuals(false);
    setStatus("Not saved yet", false);
  })();
</script>

{% endblock %}
